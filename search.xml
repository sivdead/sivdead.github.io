<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/04/29/hello-world/"/>
      <url>/2020/04/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker原理概述</title>
      <link href="/2020/04/22/rong-qi-hua/docker-detail/"/>
      <url>/2020/04/22/rong-qi-hua/docker-detail/</url>
      
        <content type="html"><![CDATA[<h2 id="1-容器是什么"><a href="#1-容器是什么" class="headerlink" title="1. 容器是什么"></a>1. 容器是什么</h2><p>引用 <a href="https://www.docker.com/resources/what-container" target="_blank" rel="noopener">Docker 官网</a>对容器的一个定义：</p><blockquote><p>What is a Container?</p><p>A standardized unit of software.</p></blockquote><p>容器是什么？一个软件的<strong>标准化单元</strong>。</p><p>我们来分析下这个定义，首先是<strong>软件</strong>，跟容器相关的是软件而不是硬件，而我们也知道软件主要分为系统软件和应用软件，而容器中运行的程序并非系统软件，它实际运行在宿主机上，与宿主机上的其他进程共用一个内核，这也是容器与传统虚拟机的一个很大区别。</p><p>再者，<strong>标准化单元</strong>，刚才我们已经说了，容器内运行的程序并非系统软件，每个软件运行都需要有必要的环境，包括一些 lib 库之类的，而如何能在复杂的环境中做到“标准化”呢？显然，<strong>隔离</strong>是一个最佳选择。将程序及其所需的环境 /lib 库之类的组织在一起，并与系统环境隔离，这就很容易做到“标准化”了。</p><p>说白了，<strong>容器其实是在一台机器上的“一组”进程，当然这组进程可能只有一个；它们有相同的特性，同样所受的限制也相同；另外既然叫做容器，很自然地我们认为它们与外界可以进行隔离/应该有一个分界线。</strong></p><p>如何隔离? Docker最初基于Linux Container(LXC) ,并在2014年正式发布1.0之前将LXC换成了自己实现的libcontainer,但归根结底,还是基于cgroups、namespace、Union File Systems等技术。</p><h2 id="2-namespace"><a href="#2-namespace" class="headerlink" title="2. namespace"></a>2. namespace</h2><h3 id="什么是-namespace"><a href="#什么是-namespace" class="headerlink" title="什么是 namespace"></a>什么是 namespace</h3><p>我们仍然以 <a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">Wiki</a> 上对 namespace 的定义开始：</p><blockquote><p><strong>Namespaces</strong> are a feature of the <a href="https://en.wikipedia.org/wiki/Linux_kernel" target="_blank" rel="noopener">Linux kernel</a> that partitions kernel resources such that one set of <a href="https://en.wikipedia.org/wiki/Process_(computing)" target="_blank" rel="noopener">processes</a> sees one set of resources while another set of processes sees a different set of resources. The feature works by having the same namespace for a set of resources and processes, but those namespaces refer to distinct resources. Resources may exist in multiple spaces. Examples of such resources are process IDs, hostnames, user IDs, file names, and some names associated with network access, and <a href="https://en.wikipedia.org/wiki/Interprocess_communication" target="_blank" rel="noopener">interprocess communication</a>.</p><p>The term “namespace” is often used for a type of namespace (e.g. process ID) as well as for a particular space of names.</p></blockquote><p>namespace 是 Linux 内核的一项功能，它可以对内核资源进行拆分，使得一组进程可以看到指定的一组资源；而另一组进程可以看到另一组不同的资源。该功能通过对一组资源和进程使用相同的namespace起作用,而这些namespace引用了不同的资源 。资源可能存在于多个空间中。 例如进程ID，主机名，用户ID，文件名以及与网络访问和进程间通信相关的某些名称。</p><p>术语“namespace”通常用于一种特定的命名空间（如进程ID）以及特定的名称空间。</p><p>简单来说: namespace 是由 Linux 内核提供的，用于进程间资源隔离的一种技术。同时 Linux 也默认提供了多种 namespace，用于对多种不同资源进行隔离。</p><table><thead><tr><th align="left">namespace 名称</th><th align="left">系统调用参数</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">Mount</td><td align="left">CLONE_NEWNS</td><td align="left">隔离挂载点</td></tr><tr><td align="left">PID</td><td align="left">CLONE_NEWPID</td><td align="left">进程编号,</td></tr><tr><td align="left">Network</td><td align="left">CLONE_NEWNET</td><td align="left">网络设备，堆栈，端口等</td></tr><tr><td align="left">IPC</td><td align="left">CLONE_NEWIPC</td><td align="left">系统 IPC, POSIX 消息队列,用于隔离进程间通信资源</td></tr><tr><td align="left">UTS</td><td align="left">CLONE_NEWUTS</td><td align="left">系统主机名和 NIS(Network Information Service) 主机名（有时称为域名),用于隔离主机名和域名</td></tr><tr><td align="left">User</td><td align="left">CLONE_NEWUSER</td><td align="left">用户和组 ID</td></tr><tr><td align="left">Cgroup</td><td align="left">CLONE_NEWCGROUP</td><td align="left">Cgroup 根目录</td></tr></tbody></table><h3 id="如何使用-namespace"><a href="#如何使用-namespace" class="headerlink" title="如何使用 namespace"></a>如何使用 namespace</h3><p>前面提到了 Linux 内核提供了以上 7 种 namespace，那如何去使用它们呢？Linux 提供了以下主要的 API 用于管理 namespace：</p><ul><li>clone()：如果是纯粹只使用 clone()，则会创建一个新进程；但如果我们传递一个或多个 CLONE_NEW* 标志给 clone()，则会根据每个标志创建对应的新 namespace 并且将子进程添加为其成员。</li><li>setns()：允许进程加入一个已存在的 namespace 中。</li><li>unshare()：允许进程（或线程）取消其执行上下文中，与其他进程（或线程）共享部分的关联，当然通俗点来说，也就是可以利用此系统调用来让当前的进程（或线程）移动至一个新的 namespace 中。</li></ul><p>查看一个进程的各namespace命令如下：</p><pre class=" language-shell"><code class="language-shell">[root@centos1 ~]# ll /proc/self/ns --time-style='+'总用量 0lrwxrwxrwx. 1 root root 0  ipc -> ipc:[4026531839]lrwxrwxrwx. 1 root root 0  mnt -> mnt:[4026531840]lrwxrwxrwx. 1 root root 0  net -> net:[4026531956]lrwxrwxrwx. 1 root root 0  pid -> pid:[4026531836]lrwxrwxrwx. 1 root root 0  user -> user:[4026531837]lrwxrwxrwx. 1 root root 0  uts -> uts:[4026531838]</code></pre><blockquote><p>/proc 是一种虚拟的文件系统。该文件系统挂载于 /proc 目录下，包含了各种用于展示内核信息的文件，并且允许进程通过普通的 I/O 调用来直接读取。/proc 文件系统对于进程都提供了一个 /proc/$PID 的目录，其中包含着进程的详细信息。<strong>/proc/self 实际上指向的就是当前指令所在的进程</strong></p><pre class=" language-shell"><code class="language-shell">[root@centos1 ~]# ll /proc |grep selflrwxrwxrwx.  1 root    root                 11 4月  23 10:55 mounts -> self/mountslrwxrwxrwx.  1 root    root                  8 4月  23 10:55 net -> self/netlrwxrwxrwx.  1 root    root                  0 1月  15 14:43 self -> 19543[root@centos1 ~]# ll /proc/self/ |grep exelrwxrwxrwx. 1 root root 0 4月  23 10:56 exe -> /usr/bin/ls</code></pre></blockquote><p>通过这个指令,我们可以看到某个docker容器进程的各namespace</p><pre class=" language-shell"><code class="language-shell">[root@centos1 ~]# ls -l --time-style="+" /proc/$(docker inspect $(docker ps -ql) --format='{{.State.Pid}}')/ns总用量 0lrwxrwxrwx. 1 polkitd input 0  ipc -> ipc:[4026532100]lrwxrwxrwx. 1 polkitd input 0  mnt -> mnt:[4026532098]lrwxrwxrwx. 1 polkitd input 0  net -> net:[4026532103]lrwxrwxrwx. 1 polkitd input 0  pid -> pid:[4026532101]lrwxrwxrwx. 1 polkitd input 0  user -> user:[4026531837]lrwxrwxrwx. 1 polkitd input 0  uts -> uts:[4026532099]</code></pre><blockquote><p><code>docker ps -ql</code>可以用来查看查询最近一次创建的容器的containerId。</p><p><code>docker inspect</code>用来查看容器的一些信息,<code>--format</code>参数使用给定的go-template来格式化输出。</p></blockquote><h4 id="pid-namespace"><a href="#pid-namespace" class="headerlink" title="pid namespace"></a>pid namespace</h4><p>在容器中，有自己的pid namespace，因此我们看到的只有PID为1的初始进程以及它的子进程，而宿主机的其他进程容器内是看不到的。通常来说，Linux启动后会先启动一个PID为1的进程，这是系统进程树的根进程，根进程会接着创建子进程来初始化系统服务。PID namespace允许在新的namespace创建一棵新的进程树，它可以有自己的PID为1的进程。在PID namespace的隔离下，子进程名字空间无法知道父进程名字空间的进程，如在Docker容器中无法看到宿主机的进程，而父进程名字空间可以看到子进程名字空间的所有进程。</p><pre class=" language-shell"><code class="language-shell">[root@centos1 ~]# ls -ls /proc/self/ns总用量 00 lrwxrwxrwx. 1 root root 0 4月  23 13:55 ipc -> ipc:[4026531839]0 lrwxrwxrwx. 1 root root 0 4月  23 13:55 mnt -> mnt:[4026531840]0 lrwxrwxrwx. 1 root root 0 4月  23 13:55 net -> net:[4026531956]0 lrwxrwxrwx. 1 root root 0 4月  23 13:55 pid -> pid:[4026531836]0 lrwxrwxrwx. 1 root root 0 4月  23 13:55 user -> user:[4026531837]0 lrwxrwxrwx. 1 root root 0 4月  23 13:55 uts -> uts:[4026531838][root@centos1 ~]# unshare --fork --pid bash[root@centos1 ~]# ls -ls /proc/self/ns总用量 00 lrwxrwxrwx. 1 root root 0 4月  23 13:56 ipc -> ipc:[4026531839]0 lrwxrwxrwx. 1 root root 0 4月  23 13:56 mnt -> mnt:[4026531840]0 lrwxrwxrwx. 1 root root 0 4月  23 13:56 net -> net:[4026531956]0 lrwxrwxrwx. 1 root root 0 4月  23 13:56 pid -> pid:[4026532162]0 lrwxrwxrwx. 1 root root 0 4月  23 13:56 user -> user:[4026531837]0 lrwxrwxrwx. 1 root root 0 4月  23 13:56 uts -> uts:[4026531838][root@centos1 ~]# ps -a  PID TTY          TIME CMD19944 pts/1    00:00:00 unshare19945 pts/1    00:00:00 bash19957 pts/1    00:00:00 ps</code></pre><p>可以看到pid的namespace已经不同了,但ps还是能看到父进程,这是因为ps命令是从/proc文件系统读取的数据,而文件系统我们还没有隔离。</p><pre class=" language-shell"><code class="language-shell">[root@centos1 ~]# unshare --fork --pid --mount-proc bash [root@centos1 ~]# ps -a  PID TTY          TIME CMD    1 pts/1    00:00:00 bash   12 pts/1    00:00:00 ps[root@centos1 ~]# ls -ls /proc/self/ns总用量 00 lrwxrwxrwx. 1 root root 0 4月  23 14:08 ipc -> ipc:[4026531839]0 lrwxrwxrwx. 1 root root 0 4月  23 14:08 mnt -> mnt:[4026532162]0 lrwxrwxrwx. 1 root root 0 4月  23 14:08 net -> net:[4026531956]0 lrwxrwxrwx. 1 root root 0 4月  23 14:08 pid -> pid:[4026532163]0 lrwxrwxrwx. 1 root root 0 4月  23 14:08 user -> user:[4026531837]0 lrwxrwxrwx. 1 root root 0 4月  23 14:08 uts -> uts:[4026531838]</code></pre><p>现在可以看到ps已经只能看到两个进程,且pid从1开始了</p><h4 id="net-namespace"><a href="#net-namespace" class="headerlink" title="net namespace"></a>net namespace</h4><p>Docker容器中另一个重要特性是网络独立(之所以不用隔离一词是因为容器的网络还是要借助宿主机的网络来通信的)，使用到Linux 的 NET Namespace、vet。veth主要的目的是为了跨NET namespace之间提供一种类似于Linux进程间通信的技术，所以veth总是成对出现，如下面的veth0和veth1。它们位于不同的NET namespace中，在veth设备任意一端接收到的数据，都会从另一端发送出去。veth实现了不同namespace的网络数据传输。</p><img src="/2020/04/22/rong-qi-hua/docker-detail/docker%E7%BD%91%E7%BB%9C.png" class="" title="bridge网络"><!-- ![docker bridge 网络](docker_detail/docker网络.png) --><p>实际演示一下</p><pre class=" language-shell"><code class="language-shell">[root@centos1 ~]# docker run -d -it  --rm --name ap1 --network bridge alpinef4be196f3b552368a31d6739020a5218022a3748b1f6719d8a798af6b2127a95[root@centos1 ~]# ip addr1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever    inet6 ::1/128 scope host       valid_lft forever preferred_lft forever2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000    link/ether 00:15:5d:f8:cb:a7 brd ff:ff:ff:ff:ff:ff    inet 192.168.81.26/21 brd 192.168.87.255 scope global noprefixroute dynamic eth0       valid_lft 56131sec preferred_lft 56131sec    inet6 fe80::951d:c7a5:f555:4b7d/64 scope link noprefixroute        valid_lft forever preferred_lft forever3: docker0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default    link/ether 02:42:e9:9c:11:f8 brd ff:ff:ff:ff:ff:ff    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0       valid_lft forever preferred_lft forever    inet6 fe80::42:e9ff:fe9c:11f8/64 scope link       valid_lft forever preferred_lft forever35: vethad7a451@if34: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master docker0 state UP group default    link/ether 02:f9:26:50:15:45 brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet6 fe80::f9:26ff:fe50:1545/64 scope link       valid_lft forever preferred_lft forever</code></pre><p>其中<code>docker0</code>即是docker中作为容器网络的bridge,<code>vethad7a451@if34</code>对应新创建的容器的veth</p><pre class=" language-shell"><code class="language-shell">[root@centos1 ~]# docker exec -it ap1 sh/ # ip addr1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever34: eth0@if35: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue state UP    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0       valid_lft forever preferred_lft forever/ # ip rdefault via 172.17.0.1 dev eth0 172.17.0.0/16 dev eth0 scope link  src 172.17.0.2</code></pre><p>进入容器内,可以看到<code>ectho@if35</code>对应着上面的<code>vethad7a451@if34</code>,通过<code>ip -r</code>也可以看到数据包是由<code>vethad7a451@if34</code> 路由到 <code>docker0</code></p><h2 id="3-cgroups"><a href="#3-cgroups" class="headerlink" title="3. cgroups"></a>3. cgroups</h2><h3 id="什么是cgroups"><a href="#什么是cgroups" class="headerlink" title="什么是cgroups"></a>什么是cgroups</h3><p>继续看wiki:</p><blockquote><p><strong>cgroups</strong>，其名称源自<strong>控制组群</strong>（英语：control groups）的简写，是<a href="https://zh.wikipedia.org/wiki/Linux内核" target="_blank" rel="noopener">Linux内核</a>的一个功能，用来限制、控制与分离一个<a href="https://zh.wikipedia.org/wiki/行程群組" target="_blank" rel="noopener">进程组</a>的<a href="https://zh.wikipedia.org/wiki/資源_(計算機科學)" target="_blank" rel="noopener">资源</a>（如CPU、内存、磁盘输入输出等）。</p><p>cgroups的一个设计目标是为不同的应用情况提供统一的接口，从控制单一进程（像<a href="https://zh.wikipedia.org/w/index.php?title=Nice&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">nice</a>）到<a href="https://zh.wikipedia.org/wiki/作業系統層虛擬化" target="_blank" rel="noopener">操作系统层虚拟化</a>（像<a href="https://zh.wikipedia.org/wiki/OpenVZ" target="_blank" rel="noopener">OpenVZ</a>，<a href="https://zh.wikipedia.org/w/index.php?title=Linux-VServer&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">Linux-VServer</a>，<a href="https://zh.wikipedia.org/wiki/LXC" target="_blank" rel="noopener">LXC</a>）。cgroups提供：</p><ul><li><strong>资源限制：</strong>组可以被设置不超过设定的<a href="https://zh.wikipedia.org/wiki/内存" target="_blank" rel="noopener">内存</a>限制；这也包括<a href="https://zh.wikipedia.org/wiki/虚拟内存" target="_blank" rel="noopener">虚拟内存</a>。</li><li><strong>优先级：</strong>一些组可能会得到大量的CPU或磁盘IO吞吐量。</li><li><strong>结算：</strong>用来度量系统实际用了多少资源。</li><li><strong>控制：</strong>冻结组或检查点和重启动。</li></ul></blockquote><p>对于容器来说,cgroups的作用就是限制容器使用的机器资源,我们直接来看实际效果</p><pre class=" language-shell"><code class="language-shell">[root@centos1 ~]# docker run -it  --rm --name ap1 -d alpine sh9182ab0c2c1e14cec2142b0d43988032a5413aa58f495f578981f13bb7541517[root@centos1 ~]# docker exec -it ap1 sh/ # sha256sum /dev/zero</code></pre><blockquote><ul><li><p>/dev/zero 会无限产生空串</p></li><li><p>sha256sum 是一个用于计算和检查 SHA256 信息的命令行工具</p><p>以上命令会让sha256sum 持续计算 /dev/zero产生的空串，从而迅速消耗cpu资源</p></li></ul></blockquote><p>这时查看容器的资源使用状况,可以看到cpu占用是100%,这是因为sha256sum是单线程的,所以最多只能占用100%</p><pre class=" language-shell"><code class="language-shell">[root@centos1 ~]# docker stats ap1 --no-streamCONTAINER ID        NAME                CPU %               MEM USAGE / LIMIT   MEM %               NET I/O             BLOCK I/O           PIDS9182ab0c2c1e        ap1                 100.00%             384KiB / 1.987GiB   0.02%               656B / 0B           0B / 0B             3</code></pre><p>现在调整容器的cpu资源限制到0.5</p><pre class=" language-shell"><code class="language-shell">[root@centos1 ~]# docker run -it  --rm --name ap1 --cpus="0.5" -d alpine sh47e45660899fe4d0acd2ad9f2c8ad78017c27e5ff63784a9ccff44a0ad0ffb11[root@centos1 ~]# [root@centos1 ~]# docker exec -it ap1 sh/ # sha256sum /dev/zero</code></pre><p>再查看资源使用情况:</p><pre class=" language-shell"><code class="language-shell">[root@centos1 ~]# docker stats ap1 --no-streamCONTAINER ID        NAME                CPU %               MEM USAGE / LIMIT   MEM %               NET I/O             BLOCK I/O           PIDSca7985a0cd17        ap1                 50.32%              316KiB / 1.987GiB   0.02%               656B / 0B           0B / 0B             3</code></pre><p>可以看到已经只占用50%了，查看容器内根进程的cgroup相关信息</p><pre class=" language-shell"><code class="language-shell">/ # cat /proc/1/cgroup 11:devices:/docker/47e45660899fe4d0acd2ad9f2c8ad78017c27e5ff63784a9ccff44a0ad0ffb1110:memory:/docker/47e45660899fe4d0acd2ad9f2c8ad78017c27e5ff63784a9ccff44a0ad0ffb119:cpuset:/docker/47e45660899fe4d0acd2ad9f2c8ad78017c27e5ff63784a9ccff44a0ad0ffb118:pids:/docker/47e45660899fe4d0acd2ad9f2c8ad78017c27e5ff63784a9ccff44a0ad0ffb117:cpuacct,cpu:/docker/47e45660899fe4d0acd2ad9f2c8ad78017c27e5ff63784a9ccff44a0ad0ffb116:perf_event:/docker/47e45660899fe4d0acd2ad9f2c8ad78017c27e5ff63784a9ccff44a0ad0ffb115:net_prio,net_cls:/docker/47e45660899fe4d0acd2ad9f2c8ad78017c27e5ff63784a9ccff44a0ad0ffb114:freezer:/docker/47e45660899fe4d0acd2ad9f2c8ad78017c27e5ff63784a9ccff44a0ad0ffb113:blkio:/docker/47e45660899fe4d0acd2ad9f2c8ad78017c27e5ff63784a9ccff44a0ad0ffb112:hugetlb:/docker/47e45660899fe4d0acd2ad9f2c8ad78017c27e5ff63784a9ccff44a0ad0ffb111:name=systemd:/docker/47e45660899fe4d0acd2ad9f2c8ad78017c27e5ff63784a9ccff44a0ad0ffb11</code></pre><p>在主机上找到对应的cgroups信息</p><pre class=" language-shell"><code class="language-shell">[root@centos1 ~]# cd /sys/fs/cgroup/cpu,cpuacct/docker/47e45660899fe4d0acd2ad9f2c8ad78017c27e5ff63784a9ccff44a0ad0ffb11/[root@centos1 47e45660899fe4d0acd2ad9f2c8ad78017c27e5ff63784a9ccff44a0ad0ffb11]# cat cpu.cfs_period_us100000[root@centos1 47e45660899fe4d0acd2ad9f2c8ad78017c27e5ff63784a9ccff44a0ad0ffb11]# cat cpu.cfs_quota_us50000</code></pre><p>其中,cfs_period_us是cpu的调度周期(单位us),cfs_quota_us是在一个调度周期内可使用的cpu时间,所以可使用的cpu资源=cfs_quota_us/cfs_period_us=0.5,与我们的配置相符。</p><blockquote><p>可以通过修改cfs_quota_us来动态调整资源限制,但建议只是用来实验,不要实际使用</p></blockquote><h2 id="4-UnionFileSystem"><a href="#4-UnionFileSystem" class="headerlink" title="4. UnionFileSystem"></a>4. UnionFileSystem</h2><h3 id="什么是UFS"><a href="#什么是UFS" class="headerlink" title="什么是UFS"></a>什么是UFS</h3><p>我们继续看wiki</p><blockquote><p><strong>Unionfs</strong> is a filesystem service for <a href="https://en.wikipedia.org/wiki/Linux" target="_blank" rel="noopener">Linux</a>, <a href="https://en.wikipedia.org/wiki/FreeBSD" target="_blank" rel="noopener">FreeBSD</a> and <a href="https://en.wikipedia.org/wiki/NetBSD" target="_blank" rel="noopener">NetBSD</a> which implements a <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">union mount</a> for other <a href="https://en.wikipedia.org/wiki/File_systems" target="_blank" rel="noopener">file systems</a>. It allows files and directories of separate file systems, known as branches, to be transparently overlaid, forming a single coherent file system. Contents of directories which have the same path within the merged branches will be seen together in a single merged directory, within the new, virtual filesystem.</p><p>When mounting branches, the priority of one branch over the other is specified. So when both branches contain a file with the same name, one gets priority over the other.</p><p>The different branches may be either <em>read-only</em> or <em>read/write</em> file systems, so that writes to the virtual, merged copy are directed to a specific real file system. This allows a file system to appear as writable, but without actually allowing writes to change the file system, also known as <a href="https://en.wikipedia.org/wiki/Copy-on-write" target="_blank" rel="noopener">copy-on-write</a>. This may be desirable when the media is physically read-only, such as in the case of <a href="https://en.wikipedia.org/wiki/Live_CD" target="_blank" rel="noopener">Live CDs</a>.</p></blockquote><p>Unionfs是一个为其他文件系统实现了联合挂载的文件系统服务。  它允许透明地覆盖各独立文件系统（称为分支）的文件和目录，从而形成单个一致的文件系统。 在合并分支中具有相同路径的目录的内容将在新的虚拟文件系统内的被整合到一起。</p><p>分支具有优先级,在挂载分支时,优先级高的会覆盖优先级低的。</p><p>不同的分支可以是只读文件系统，也可以是读/写文件系统，因此对虚拟合并副本的写操作将定向到特定的实际文件系统。 这使文件系统看起来可写，但实际上并没有修改原有的文件系统，也称为写入时复制(Copy on write)。 </p><p>简单来说,ufs就是将不同的目录挂载到同一个目录,具体到docker,我们通过一个简单的dockerfile来说明。</p><pre class=" language-dockerfile"><code class="language-dockerfile">#基础镜像(只读属性)FROM openjdk:8u232-jre#会创建对应目录WORKDIR /usr/local/demo#环境变量ENV SERVER_PORT=8000ENV PROFILE=prodENV LOG_LEVEL=INFOEXPOSE ${SERVER_PORT}RUN rm -f /etc/localtime \&& ln -sv /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \&& echo "Asia/Shanghai" > /etc/timezoneCOPY demo.jar .ENTRYPOINT ["sh", "-c", "/usr/local/openjdk-8/bin/java -jar -Dserver.port=$SERVER_PORT -Dspring.profiles.active=$PROFILE demo.jar "]</code></pre><p>基础镜像<code>openjdk</code>即是一个只读文件系统,对后面的每一条指令,都会生成一层独立的镜像,可以在构建镜像时看到对应的输出.</p><pre class=" language-shell"><code class="language-shell">[root@centos1 demo]# docker build -t demo:0.0.1 .Sending build context to Docker daemon  19.32MBStep 1/9 : FROM openjdk:8u232-jre ---> b3f3caa5767cStep 2/9 : WORKDIR /usr/local/demo ---> Using cache ---> bb90e5699704Step 3/9 : ENV SERVER_PORT=8000 ---> Using cache ---> 14bdb24ab9e5Step 4/9 : ENV PROFILE=prod ---> Using cache ---> b98469bc4aacStep 5/9 : ENV LOG_LEVEL=INFO ---> Using cache ---> f576102d063bStep 6/9 : EXPOSE ${SERVER_PORT} ---> Using cache ---> 353ffc6e9e53Step 7/9 : RUN rm -f /etc/localtime && ln -sv /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && echo "Asia/Shanghai" > /etc/timezone ---> Using cache ---> bf6ba739fdd2Step 8/9 : COPY demo.jar . ---> Using cache ---> d7c33c8957c6Step 9/9 : ENTRYPOINT ["sh", "-c", "/usr/local/openjdk-8/bin/java -jar -Dserver.port=$SERVER_PORT -Dspring.profiles.active=$PROFILE demo.jar "] ---> Using cache ---> c43c267da907Successfully built c43c267da907Successfully tagged demo:0.0.1</code></pre><blockquote><p> 因为之前有构建过,所以可以看到上面输出的所有layer都是直接用的缓存的,docker对镜像构建及拉取都使用到了layer缓存。</p></blockquote><p>这里推荐一个小工具<a href="https://github.com/wagoodman/dive" target="_blank" rel="noopener">dive</a>,可以查看到某个镜像每一层layer的具体变动信息,对于分析镜像很有帮助。</p><p>docker的镜像信息存储在/var/lib/docker目录,其中layer层信息取决于当前docker版本使用的ufs,如aufs、overlay、overlay2等,目前这个虚拟机上dockerce版本是19.03.8,使用的是overlay2,layer层信息存储在/var/lib/docker/overlay2。</p><pre class=" language-shell"><code class="language-shell">[root@centos1 demo]# docker pull alpineUsing default tag: latestlatest: Pulling from library/alpinecbdbe7a5bc2a: Pull complete Digest: sha256:9a839e63dad54c3a6d1834e29692c8492d93f90c59c978c1ed79109ea4fb9a54Status: Downloaded newer image for alpine:latestdocker.io/library/alpine:latest[root@centos1 demo]# docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEalpine              latest              f70734b6a266        4 days ago          5.61MB[root@centos1 demo]# docker image inspect f70734b6a266 --format="{{json .GraphDriver}}" {    "Data": {        "MergedDir": "/var/lib/docker/overlay2/90da000e4e9370bb978bd1c47beca01b32acad5f5cb1c4ed6de1383ee66262b9/merged",        "UpperDir": "/var/lib/docker/overlay2/90da000e4e9370bb978bd1c47beca01b32acad5f5cb1c4ed6de1383ee66262b9/diff",        "WorkDir": "/var/lib/docker/overlay2/90da000e4e9370bb978bd1c47beca01b32acad5f5cb1c4ed6de1383ee66262b9/work"    },    "Name": "overlay2"}[root@centos1 demo]# docker run -idt --rm --name ap1 alpine 4b69a3640c35ac78790d16239902c5849da410965ebdd6ad98595fd0792aa2f9[root@centos1 demo]# docker inspect $(docker ps -ql) --format="{{json .GraphDriver}}"{    "Data": {        "LowerDir": "/var/lib/docker/overlay2/9b61a604e85ab460759f27c7d7b0be10b7a6370378de7ee17f2835fc9d0d59c0-init/diff:/var/lib/docker/overlay2/90da000e4e9370bb978bd1c47beca01b32acad5f5cb1c4ed6de1383ee66262b9/diff",        "MergedDir": "/var/lib/docker/overlay2/9b61a604e85ab460759f27c7d7b0be10b7a6370378de7ee17f2835fc9d0d59c0/merged",        "UpperDir": "/var/lib/docker/overlay2/9b61a604e85ab460759f27c7d7b0be10b7a6370378de7ee17f2835fc9d0d59c0/diff",        "WorkDir": "/var/lib/docker/overlay2/9b61a604e85ab460759f27c7d7b0be10b7a6370378de7ee17f2835fc9d0d59c0/work"    },    "Name": "overlay2"}[root@centos1 docker]# ls -l overlay2/总用量 0drwx------. 3 root root     47 4月  28 16:53 90da000e4e9370bb978bd1c47beca01b32acad5f5cb1c4ed6de1383ee66262b9drwx------. 5 root root     69 4月  28 16:53 9b61a604e85ab460759f27c7d7b0be10b7a6370378de7ee17f2835fc9d0d59c0drwx------. 4 root root     72 4月  28 16:53 9b61a604e85ab460759f27c7d7b0be10b7a6370378de7ee17f2835fc9d0d59c0-initbrw-------. 1 root root 253, 0 1月  15 14:45 backingFsBlockDevdrwx------. 2 root root    108 4月  28 16:53 l</code></pre><p>可以看到,拉取镜像时,会在/var/lib/docker/overlay2新增一个layer(这是因为alpine只有一层),运行alpine时,又会新增两层,其中带init的为只读层,用来存储容器的初始化信息如环境变量等,不带的则为容器层,其中,容器层的mergedDir即通过ufs挂载出来的目录,lowerDir为它的层目录。</p><h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h2><blockquote><ol><li><a href="https://gitbook.cn/gitchat/column/5d70cfdc4dc213091bfca46f" target="_blank" rel="noopener">Gitchat-Docker 核心知识必知必会</a></li><li><a href="https://fuckcloudnative.io/posts/understanding-cgroups-part-1-basics/" target="_blank" rel="noopener">Linux Cgroup 入门教程</a></li><li><a href="https://blog.csdn.net/luckyapple1028/article/details/77916194" target="_blank" rel="noopener">深入理解overlayfs</a></li></ol></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 容器化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker和k8s简介</title>
      <link href="/2019/12/15/rong-qi-hua/container-intro/"/>
      <url>/2019/12/15/rong-qi-hua/container-intro/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><h3 id="什么是-docker"><a href="#什么是-docker" class="headerlink" title="什么是 docker"></a>什么是 docker</h3><ul><li>docker 是一个开源的软件部署解决方案；</li><li>docker 也是轻量级的应用容器框架；</li><li>docker 可以打包、发布、运行任何的应用(Build,Ship,Run anywhere)。</li><li>Docker 的基础是 Linux 容器(LXC)等技术。在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。</li></ul><h3 id="Docker-vs-传统虚拟化"><a href="#Docker-vs-传统虚拟化" class="headerlink" title="Docker vs 传统虚拟化"></a>Docker vs 传统虚拟化</h3><img src="/2019/12/15/rong-qi-hua/container-intro/virtualization.png" class="" title="虚拟化"><img src="/2019/12/15/rong-qi-hua/container-intro/docker-1.png" class="" title="Docker"><blockquote><p>容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。相比传统虚拟化技术,Docker 省去了操作系统的资源占用,达到了更高的资源利用率.</p></blockquote><h3 id="为什么用-Docker"><a href="#为什么用-Docker" class="headerlink" title="为什么用 Docker"></a>为什么用 Docker</h3><h4 id="高效、轻量"><a href="#高效、轻量" class="headerlink" title="- 高效、轻量"></a>- 高效、轻量</h4><p>对比虚拟机，Docker 提供了一个经济、高效、可行的方案，可以节约出更多的资源投入到业务中去，让应用程序产生更高的效益。</p><h4 id="快速、一致交付"><a href="#快速、一致交付" class="headerlink" title="- 快速、一致交付"></a>- 快速、一致交付</h4><p>在本地容器中得到一套标准的应用或服务的运行环境，简化开发的生命周期。对于整个应用迭代来说，更加适合持续集成( Continuous Integration )和持续交付( Continuous Delivery )。</p><h4 id="跨平台部署和动态伸缩"><a href="#跨平台部署和动态伸缩" class="headerlink" title="- 跨平台部署和动态伸缩"></a>- 跨平台部署和动态伸缩</h4><p>很轻松的运行在开发者本地的电脑，云服务器，甚至是混合环境中；同时，轻量性和高可移植性能够很好的帮助我们完成应用的动态伸缩，大幅提高应用的健壮性。</p><h4 id="完美契合微服务"><a href="#完美契合微服务" class="headerlink" title="- 完美契合微服务"></a>- 完美契合微服务</h4><p>微服务架构本身就意味着需要对若干个容器服务进行治理，每个微服务都应可以独立部署、扩容、监控,而 Docker 正是为此而生。</p><h3 id="QuickStart"><a href="#QuickStart" class="headerlink" title="QuickStart"></a>QuickStart</h3><ol><li>上手</li></ol><p>假设我们需要在本地安装一个 mysql 数据库,如果是以前,我们需要下载、安装、配置等,但是有了 docker,简单执行一条命令即可:</p><pre class=" language-shell"><code class="language-shell">$ docker run -p "3306:3306" --name my-mysql -e "MYSQL_ROOT_PASSWORD=123456" mysql</code></pre><blockquote><p><code>docker run</code>命令会为我们启动一个容器,其中<code>--name</code>参数指定了容器的名字,<br><code>-e</code>参数指定容器了的环境变量,Docker 会将环境变量设置到启动容器的环境变&gt;量中.<code>-p</code>指定了容器的端口映射,Docker 容器运行在一个独立的网络环境中,需要通过端口映射来暴露服务.</p></blockquote><p>可以看到输出结果如下:</p><pre class=" language-shell"><code class="language-shell">Unable to find image 'mysql:latest' locallylatest: Pulling from library/mysql743f2d6c1f65: Already exists3f0c413ee255: Pull completeaef1ef8f1aac: Pull completef9ee573e34cb: Pull complete3f237e01f153: Pull completef9da32e8682a: Pull complete4b8da52fb357: Pull complete3416ca8f6890: Pull complete786698c2d5de: Pull complete4ddf84d07bd1: Pull completecd3aa23461b6: Pull complete9f287a2a95ad: Pull completeDigest: sha256:711df5b93720801b3a727864aba18c2ae46c07f9fe33d5ce9c1f5cbc2c035101Status: Downloaded newer image for mysql:latestInitializing database2019-05-30T14:02:16.286390Z 0 [Warning] [MY-011070] [Server] 'Disabling symbolic links using --skip-symbolic-links (or equivalent) is the default. Consider not using this option as it' is deprecated and will be removed in a future release.2019-05-30T14:02:16.286447Z 0 [System] [MY-013169] [Server] /usr/sbin/mysqld (mysqld 8.0.16) initializing of server in progress as process 282019-05-30T14:02:52.389697Z 5 [Warning] [MY-010453] [Server] root@localhost is created with an empty password ! Please consider switching off the --initialize-insecure option.2019-05-30T14:03:11.770831Z 0 [System] [MY-013170] [Server] /usr/sbin/mysqld (mysqld 8.0.16) initializing of server has completedDatabase initializedMySQL init process in progress...MySQL init process in progress...MySQL init process in progress...2019-05-30T14:03:14.880462Z 0 [Warning] [MY-011070] [Server] 'Disabling symbolic links using --skip-symbolic-links (or equivalent) is the default. Consider not using this option as it' is deprecated and will be removed in a future release.2019-05-30T14:03:14.880530Z 0 [System] [MY-010116] [Server] /usr/sbin/mysqld (mysqld 8.0.16) starting as process 792019-05-30T14:03:17.819022Z 0 [Warning] [MY-010068] [Server] CA certificate ca.pem is self signed.2019-05-30T14:03:17.879218Z 0 [Warning] [MY-011810] [Server] Insecure configuration for --pid-file: Location '/var/run/mysqld' in the path is accessible to all OS users. Consider choosing a different directory.2019-05-30T14:03:17.892082Z 0 [System] [MY-010931] [Server] /usr/sbin/mysqld: ready for connections. Version: '8.0.16'  socket: '/var/run/mysqld/mysqld.sock'  port: 0  MySQL Community Server - GPL.2019-05-30T14:03:17.950744Z 0 [System] [MY-011323] [Server] X Plugin ready for connections. Socket: '/var/run/mysqld/mysqlx.sock'Warning: Unable to load '/usr/share/zoneinfo/iso3166.tab' as time zone. Skipping it.Warning: Unable to load '/usr/share/zoneinfo/leap-seconds.list' as time zone. Skipping it.Warning: Unable to load '/usr/share/zoneinfo/zone.tab' as time zone. Skipping it.Warning: Unable to load '/usr/share/zoneinfo/zone1970.tab' as time zone. Skipping it.2019-05-30T14:03:31.156745Z 0 [System] [MY-010910] [Server] /usr/sbin/mysqld: Shutdown complete (mysqld 8.0.16)  MySQL Community Server - GPL.MySQL init process done. Ready for start up.2019-05-30T14:03:31.507777Z 0 [Warning] [MY-011070] [Server] 'Disabling symbolic links using --skip-symbolic-links (or equivalent) is the default. Consider not using this option as it' is deprecated and will be removed in a future release.2019-05-30T14:03:31.507843Z 0 [System] [MY-010116] [Server] /usr/sbin/mysqld (mysqld 8.0.16) starting as process 12019-05-30T14:03:33.641301Z 0 [Warning] [MY-010068] [Server] CA certificate ca.pem is self signed.2019-05-30T14:03:33.689783Z 0 [Warning] [MY-011810] [Server] Insecure configuration for --pid-file: Location '/var/run/mysqld' in the path is accessible to all OS users. Consider choosing a different directory.2019-05-30T14:03:33.702444Z 0 [System] [MY-010931] [Server] /usr/sbin/mysqld: ready for connections. Version: '8.0.16'  socket: '/var/run/mysqld/mysqld.sock'  port: 3306  MySQL Community Server - GPL.2019-05-30T14:03:34.005880Z 0 [System] [MY-011323] [Server] X Plugin ready for connections. Socket: '/var/run/mysqld/mysqlx.sock' bind-address: '::' port: 33060</code></pre><p>在执行<code>docker run</code>时,Docker 首先会去 Docker Server 上查找对应的镜像,如果找不到,再去配置的镜像仓库服务器(Registry)查找,找了之后,再去对应的镜像仓库(Repository)下载镜像。可以看到镜像的下载是分了很多层的,这是因为 Docker 镜像都是由一层一层的只读层(Layer)堆叠而成的,而容器则是由多个只读层加上一层读写层。</p><p>启动成功后,我们尝试连接数据库:</p><pre class=" language-shell"><code class="language-shell">$ mysql -h127.0.0.1 -P3306  -uroot -p123456mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 16Server version: 8.0.16 MySQL Community Server - GPLCopyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.</code></pre><p>可以看到连接成功,mysql 版本号为最新 8.0.16,如果我们想切换到 5.6 版本呢?</p><pre class=" language-shell"><code class="language-shell">docker run -p "3306:3306" --name my-mysql -e "MYSQL_ROOT_PASSWORD=123456" mysql:5.6</code></pre><blockquote><p>mysql:5.6 中的 5.6 即是版本号,这里对应的其实是 Docker 镜像的标签(TAG),Docker 通过标签来对镜像的版本进行定义,如果不指定标签,则默认使用<code>latest</code>。</p></blockquote><p>通过更换镜像的标签,我们可以运行不同版本的镜像而无需重复下载-&gt;配置-&gt;启动这一步骤,这便是 Docker 优于传统部署的地方。</p><ol start="2"><li>构建自己的镜像</li></ol><p>接下来我们来写一个简单的计数器应用 k8s-demo 并将其构建为 Docker 镜像,应用使用 Go 语言开发,使用 go module 作为依赖管理工具,redis 作为存储,通过 REST API 对外暴露接口.</p><p>接口列表：</p><table><thead><tr><th>方法</th><th>路径</th><th>说明</th></tr></thead><tbody><tr><td>GET</td><td>/score</td><td>获取当前分数</td></tr><tr><td>PUT</td><td>/score</td><td>增加分数</td></tr><tr><td>DELETE</td><td>/score</td><td>减少分数</td></tr></tbody></table><p>连接 Redis 的代码:</p><pre class=" language-shell"><code class="language-shell">/*创建连接池*/func createRedisPool() *redis.Pool {    // 建立连接池    rc := &redis.Pool{        MaxIdle:     5,        MaxActive:   10,        IdleTimeout: 30 * time.Second,        Wait:        true,        Dial: func() (redis.Conn, error) {            con, err := redis.Dial("tcp", os.Getenv("REDIS_HOST")+":"+os.Getenv("REDIS_PORT"),                redis.DialPassword(os.Getenv("REDIS_PASSWORD")),                redis.DialDatabase(0),                redis.DialConnectTimeout(30*time.Second),                redis.DialReadTimeout(30*time.Second),                redis.DialWriteTimeout(30*time.Second))            if err != nil {                return nil, err            }            return con, nil        },    }    return rc}</code></pre><p>其中连接 redis 的参数信息全部来自于系统的环境变量,这些都需要我们在启动的时候指定。</p><p>因为镜像中无法翻墙,所以我预先使用<code>go mod vendor</code>将依赖包下载到项目目录,在构建过程中直接使用项目目录的依赖。</p><p>Dockerfile:</p><pre class=" language-shell"><code class="language-shell"># 起始镜像FROM golang:1.12.1 AS build# 工作目录WORKDIR /home/app/k8s-demo# 将当前目录下的所有文件添加至镜像中ADD . .# 执行打包命令 -mod=vendor 使用vendor打包 -installsuffix 加入C语言依赖库# -a 如果文件已存在,强制重新构建RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -mod=vendor .# golang打出来的包是不需要依赖golang环境的,所以我们可以使用多阶段构建来构建一个很轻量的包FROM scratch AS prod# 从build构建中复制文件到新的镜像中COPY --from=build /home/app/k8s-demo/k8s-demo /home/app/k8s-demo# 镜像入口ENTRYPOINT ["/home/app/k8s-demo"]# 暴露端口EXPOSE 8081</code></pre><blockquote><p>一个标准的 Dockerfile 一般包含两部分</p><ol><li><code>FROM &lt;IMAGE-NAME&gt;</code> 表示镜像的基础镜像,我们已经知道一个 Docker 镜像是由多个只读层组成的,而构建一个新的镜像就相当于在原有的只读层基础上增加了若干层,其中,Dockerfile 中的每一行命令都对应一层.</li><li><code>ENTRYPOINT ["COMMAND"]</code>或<code>CMD ["COMMAND"]</code> 是容器启动时运行的命令,每一个 Docker 容器都会有一个前台程序(即<code>ENTRYPOINT</code>或<code>CMD</code>指定的命令)在运行,可以认为这个前台程序的生命周期=容器的生命周期,程序停止,容器也就停止了。</li></ol></blockquote><p>使用<code>docker build</code>命令来构建镜像</p><pre class=" language-shell"><code class="language-shell">$ docker build -t sivdead/k8s-demo:0.0.1 .Sending build context to Docker daemon  10.83MBStep 1/8 : FROM golang:1.12.1 AS build ---> 213fe73a3852Step 2/8 : WORKDIR /home/app/k8s-demo ---> Using cache ---> d956750f77a6Step 3/8 : ADD . . ---> 4af8a226fc44Step 4/8 : RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -mod=vendor . ---> Running in 16d539aff688Removing intermediate container 16d539aff688 ---> 5b94044c0976Step 5/8 : FROM scratch AS prod --->Step 6/8 : COPY --from=build /home/app/k8s-demo/k8s-demo /usr/bin/k8s-demo ---> ff1e464c53d6Step 7/8 : ENTRYPOINT ["/usr/bin/k8s-demo"] ---> Running in 154ccc263229Removing intermediate container 154ccc263229 ---> 7b79e52d4dcaStep 8/8 : EXPOSE 8081 ---> Running in 7f089d0fe674Removing intermediate container 7f089d0fe674 ---> aff6c183e5a0Successfully built aff6c183e5a0Successfully tagged sivdead/k8s-demo:0.0.1</code></pre><blockquote><p>可以看到<code>FROM scratch</code>这里并没有生成 layer,这是因为 scratch 这个基础镜像比较特殊,它相当于什么都不做。</p></blockquote><p>推送镜像到 Docker Hub(需要先注册 Docker Hub 账号)(可选)</p><pre class=" language-shell"><code class="language-shell">$ docker push sivdead/k8s-demo:0.0.1The push refers to repository [docker.io/sivdead/k8s-demo]f2227fbd4aaf: Pushed0.0.1: digest: sha256:2ccfa2b3cd0a10f867eb1bb7f637494ac2e38a0193736caf0c5c3ba2503e4277 size: 528</code></pre><p>启动容器</p><p>因为应用依赖 redis,所以我们使用 docker-compose 来启动两个关联的容器(应用和 redis)。</p><p>docker-compose.yml</p><pre class=" language-shell"><code class="language-shell">version: "3"services:  k8s-demo:    image: sivdead/k8s-demo:0.0.3    ports:      - 8081:8081    # 环境变量,这里配置的环境变量会在容器启动时配置到容器的环境变量中    # 并由应用来引用    environment:      REDIS_HOST: k8s-demo-redis      REDIS_PORT: 6379      REDIS_PASSWORD: 123456    networks:      - k8s-demo    depends_on:      - k8s-demo-redis  k8s-demo-redis:    image: redis:4.0    networks:      - k8s-demo    command: redis-server --requirepass 123456#两个容器共享同一个网络来互相通信networks:  k8s-demo:</code></pre><p>启动应用:</p><pre class=" language-shell"><code class="language-shell">$ docker-compose up -dCreating k8s-demo_k8s-demo-redis_1 ... doneCreating k8s-demo_k8s-demo_1       ... done</code></pre><p>可以使用<code>docker-compose logs -f</code>来查看启动过程.</p><pre class=" language-shell"><code class="language-shell">$ docker-compose logs -fAttaching to k8s-demo_k8s-demo_1, k8s-demo_k8s-demo-redis_1k8s-demo_1        | [GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.k8s-demo_1        |k8s-demo_1        | [GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.k8s-demo_1        |  - using env:       export GIN_MODE=releasek8s-demo_1        |  - using code:      gin.SetMode(gin.ReleaseMode)k8s-demo_1        |k8s-demo_1        | [GIN-debug] GET    /hello                    --> main.indexHandler.func1 (3 handlers)k8s-demo_1        | [GIN-debug] PUT    /score/                   --> main.main.func1 (3 handlers)k8s-demo_1        | [GIN-debug] GET    /score/                   --> main.main.func2 (3 handlers)k8s-demo_1        | [GIN-debug] DELETE /score/                   --> main.main.func3 (3 handlers)k8s-demo_1        | time="2019-05-27T17:17:24Z" level=info msg="listening at :8081"k8s-demo_1        | [GIN-debug] Listening and serving HTTP on :8081k8s-demo-redis_1  | 1:C 27 May 17:17:23.244 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Ook8s-demo-redis_1  | 1:C 27 May 17:17:23.260 # Redis version=4.0.14, bits=64, commit=00000000, modified=0, pid=1, just startedk8s-demo-redis_1  | 1:C 27 May 17:17:23.260 # Configuration loadedk8s-demo-redis_1  | 1:M 27 May 17:17:23.261 * Running mode=standalone, port=6379.k8s-demo-redis_1  | 1:M 27 May 17:17:23.261 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.k8s-demo-redis_1  | 1:M 27 May 17:17:23.261 # Server initializedk8s-demo-redis_1  | 1:M 27 May 17:17:23.261 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.k8s-demo-redis_1  | 1:M 27 May 17:17:23.261 * Ready to accept connections</code></pre><h3 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h3><img src="/2019/12/15/rong-qi-hua/container-intro/docker%E7%BB%93%E6%9E%84.png" class="" title="Docker结构"><blockquote><p>Docker 使用 c/s 架构,client 实现容器和镜像的管理，为用户提供统一的操作界面.client 通过 REST API 与 server 进行通信,在构建容器时,server 首先从本地查找镜像,如果找不到,再从可用的 Docker regisry 上下载.client 和 server 可以运行在同一个机器,也可以跨主机远程通信.</p></blockquote><h3 id="Docker-核心概念"><a href="#Docker-核心概念" class="headerlink" title="Docker 核心概念"></a>Docker 核心概念</h3><h4 id="镜像-image"><a href="#镜像-image" class="headerlink" title="- 镜像(image)"></a>- 镜像(image)</h4><p>Docker 镜像就是一个只读的模板。例如：一个镜像可以包含一个完整的操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。Docker 使用 UFS(Union File System)来将多个只读文件(Read only layer)堆叠到一起。</p><h4 id="仓库-repository"><a href="#仓库-repository" class="headerlink" title="- 仓库(repository)"></a>- 仓库(repository)</h4><p>仓库是集中存放镜像文件的场所。仓库分为公开仓库（Public）和私有仓库（Private）两种形式。当用户创建了自己的镜像之后,可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。</p><h4 id="容器-container"><a href="#容器-container" class="headerlink" title="- 容器(container)"></a>- 容器(container)</h4><p>Docker 利用容器（Container）来运行应用。容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。可以把容器看做是一个简易版的 Linux 环境（包括 root 用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。因为一个容器就是一个完整的操作系统,所以可以实现 Run anywhere 的效果。容器实际上就是在镜像的最上层加上一层可读写层。</p><h4 id="网络-network"><a href="#网络-network" class="headerlink" title="- 网络(network)"></a>- 网络(network)</h4><p>在 Docker 中，实现了强大的网络功能，我们不但能够十分轻松的对每个容器的网络进行配置，还能在容器间建立虚拟网络，将数个容器包裹其中，同时与其他网络环境隔离。</p><h4 id="数据卷-volume"><a href="#数据卷-volume" class="headerlink" title="- 数据卷(volume)"></a>- 数据卷(volume)</h4><p>基于 Docker 底层的 Union File System 技术。在 UnionFS 的加持下，除了能够从宿主操作系统中挂载目录外，还能够建立独立的目录持久存放数据，或者在容器间共享。</p><h3 id="Docker-安装部署"><a href="#Docker-安装部署" class="headerlink" title="Docker 安装部署"></a>Docker 安装部署</h3><p>Docker 安装非常简单,windows 系统可以直接从官网下载 exe 安装包,linux 系统也可以通过添加 repo 然后使用 apt/yum 直接安装,具体步骤可以百度。</p><blockquote><p>ps：对于 windows 系统,新版的 Docker for windows 需要启用 Hyper-v,而旧版的 Docker ToolBox 依赖 VM VitualBox,如果使用旧版的安装,系统又启用了 hyper-v,则需要手动在创建 Docker machine 时指定使用 hyper-v 还是 VM VitualBox。</p></blockquote><h3 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h3><h4 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h4><pre class=" language-shell"><code class="language-shell">$ docker pull</code></pre><p>从仓库获取所需要的镜像。</p><p>使用示例：</p><pre class=" language-shell"><code class="language-shell">$ docker pull hello-world</code></pre><p>拉取镜像时,如果没有指明 registry,则默认从 Docker Hub 拉取;如果没有指定所有者,默认使用 official;如果没有指定 tag,默认使用 latest。</p><blockquote><p>因为 Docker Hub 镜像仓库在国外的原因,拉取镜像会很慢,推荐使用阿里云镜像加速,具体使用参照阿里云文档: <a href="https://cr.console.aliyun.com/cn-shenzhen/instances/mirrors" target="_blank" rel="noopener">容器镜像服务-镜像加速器</a> .</p></blockquote><h4 id="查看镜像列表"><a href="#查看镜像列表" class="headerlink" title="查看镜像列表"></a>查看镜像列表</h4><pre class=" language-shell"><code class="language-shell">docker images</code></pre><p>列出所有已经下载到 server 的镜像</p><p>使用示例：</p><pre class=" language-shell"><code class="language-shell">$ docker imagesREPOSITORY               TAG                 IMAGE ID            CREATED             SIZEcentos                   centos6             6a77ab6655b9        8 weeks ago         194.6 MBubuntu                   latest              2fa927b5cdd3        9 weeks ago         122 MB</code></pre><p>在列出信息中，可以看到几个字段信息</p><ul><li>来自于哪个仓库，比如 ubuntu</li><li>镜像的标记，比如 14.04</li><li>它的 ID 号（唯一）</li><li>创建时间</li><li>镜像大小</li></ul><h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h4><pre class=" language-shell"><code class="language-shell">docker build</code></pre><p>使用 Dockerfile 来构建一个镜像,Dockerfile 相当于一个说明文档,告诉 Docker 应该如何构建镜像.</p><p>Dockerfile 示例</p><pre class=" language-shell"><code class="language-shell">#初始镜像FROM golang:1.12.1 AS build#指定工作目录WORKDIR /home/app/k8s-demo#添加文件到镜像ADD . .#执行命令RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -mod=vendor .#启动时执行命令CMD ["./k8s-demo"]</code></pre><p>更详细的语法说明请参考 <a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">Dockerfile</a></p><p>编写完 Dockerfile 后可以使用<code>docker build</code>来构建镜像</p><pre class=" language-shell"><code class="language-shell">docker build -t sivdead/k8s-demo:lastet</code></pre><h4 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h4><pre class=" language-shell"><code class="language-shell">docker run</code></pre><p>从指定镜像创建容器</p><p>部署 docker 后,可以使用以下命令来判断是否部署成功</p><pre class=" language-shell"><code class="language-shell">docker run hello-world</code></pre><p>正常情况应该输出</p><pre class=" language-shell"><code class="language-shell">Unable to find image 'hello-world:latest' locallylatest: Pulling from library/hello-world1b930d010525: Already existsDigest: sha256:0e11c388b664df8a27a901dce21eb89f11d8292f7fca1b3e3c4321bf7897bffeStatus: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.    (amd64) 3. The Docker daemon created a new container from that image which runs the    executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it    to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/</code></pre><h4 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h4><pre class=" language-shell"><code class="language-shell">docker push</code></pre><p>用户可以通过 docker push 命令，把自己创建的镜像上传到仓库中来共享。例如，用户在 Docker Hub 上完成注册后，可以推送自己的镜像到仓库中。</p><p>运行实例：</p><pre class=" language-shell"><code class="language-shell">docker push sivdead/k8s-demo:lastet</code></pre><h4 id="查看运行中的容器"><a href="#查看运行中的容器" class="headerlink" title="查看运行中的容器"></a>查看运行中的容器</h4><pre class=" language-shell"><code class="language-shell">docker ps</code></pre><p>类似镜像,每一个容器都有一个唯一的 container id 标识.</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>所有 docker 命令可以使用<code>docker help</code>查看,也可以在<a href="https://docs.docker.com/v17.09/engine/reference/run/" target="_blank" rel="noopener">Docker 官方文档</a>上查看。</p><h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><p>当需要启动多个容器,且多个容器之间需要通信时,可以在<code>docker run</code>参数中指定一个共同的<code>network</code>来实现,但这样比较不方便,这时候,可以使用 docker compose 来同时启动多个容器.</p><p>Docker Compose 是一个简单的 Docker 容器的编排工具，通过 YAML 文件配置需要运行的应用，然后通过 compose up 命令启动多个服务对应的容器实例。现版本的 Docker 中默认集成了 Compose,不需要另外安装。</p><p>docker-compose.yaml 示例：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3"</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">k8s-demo</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> sivdead/k8s<span class="token punctuation">-</span>demo<span class="token punctuation">:</span>0.0.3    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> 8081<span class="token punctuation">:</span><span class="token number">8081</span>    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token key atrule">REDIS_HOST</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo<span class="token punctuation">-</span>redis      <span class="token key atrule">REDIS_PORT</span><span class="token punctuation">:</span> <span class="token number">6379</span>      <span class="token key atrule">REDIS_PASSWORD</span><span class="token punctuation">:</span> <span class="token number">123456</span>    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> k8s<span class="token punctuation">-</span>demo    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> k8s<span class="token punctuation">-</span>demo<span class="token punctuation">-</span>redis  <span class="token key atrule">k8s-demo-redis</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis<span class="token punctuation">:</span><span class="token number">4.0</span>    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> k8s<span class="token punctuation">-</span>demo    <span class="token key atrule">command</span><span class="token punctuation">:</span> redis<span class="token punctuation">-</span>server <span class="token punctuation">-</span><span class="token punctuation">-</span>requirepass 123456<span class="token key atrule">networks</span><span class="token punctuation">:</span>  k8s<span class="token punctuation">-</span>demo<span class="token punctuation">:</span></code></pre><p>上图中指定了两个镜像 k8s-dmeo 和 redis,使用同一个 network:k8s-demo。</p><p>启动:</p><pre class=" language-shell"><code class="language-shell">docker-compose up -d</code></pre><p>其中<code>-d</code> 用来使其在后台启动</p><p>停止:</p><pre class=" language-shell"><code class="language-shell">docker-compose down</code></pre><p>Docker compose 配置文件具体编写规则可以参考<a href="https://docs.docker.com/v17.09/compose/compose-file/" target="_blank" rel="noopener">官网</a>.</p><h3 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h3><p>Kubernetes 是 Google 开源的容器集群管理系统，使用 Go 语言实现，其提供应用部署、维护、 扩展机制等功能。目前可以在 GCE、vShpere、CoreOS、OpenShift、Azure 等平台使用 k8s。</p><p>国内目前 Aliyun 也提供了基于 k8s 的服务治理平台。如果是基于物理机、虚拟机搭建的 Docker 集群的话，也可以直接部署、运行 k8s。在微服务的集群环境下，Kubernetes 可以很方便管理跨机器的微服务容器实例。</p><h3 id="为什么需要-Kubernetes"><a href="#为什么需要-Kubernetes" class="headerlink" title="为什么需要 Kubernetes"></a>为什么需要 Kubernetes</h3><p>真实的生产环境应用会包含多个容器，而这些容器还很可能会跨越多个服务器主机部署。使用 Kubernetes，可以快速精准地部署应用程序，进行即时伸缩、灰度发布。</p><h3 id="Kubernetes-能做什么"><a href="#Kubernetes-能做什么" class="headerlink" title="Kubernetes 能做什么"></a>Kubernetes 能做什么</h3><p>目前 k8s 基本是公认的最强大开源服务治理技术之一。其主要提供以下功能：</p><ul><li>自动化地基于 Docker 或其他容器服务(runc/Containerd 等)对服务实例进行部署和复制</li><li>以集群的方式运行，可以管理跨机器的容器，以及滚动升级、存储编排。</li><li>内置了基于 Docker 的服务发现和负载均衡模块</li><li>K8s 提供了强大的自我修复机制,会对崩溃的容器进行替换(对用户，甚至开发团队都无感知)，并可随时扩容、缩容。让容器管理更加弹性化。</li></ul><h3 id="Kubernetes-架构"><a href="#Kubernetes-架构" class="headerlink" title="Kubernetes 架构"></a>Kubernetes 架构</h3><p>Kubernetes 整体上遵循 C/S 架构,CLI 即 kubectl 命令行工具,CLI 通过 REST API 与 Server 进行通信。</p><pre class=" language-shell"><code class="language-shell">                               +-------------+                               |             |                               |             |               +---------------+                               |             |       +-----> |     Node 1    |                               | Kubernetes  |       |       +---------------++-----------------+            |   Server    |       ||       CLI       |            |             |       |       +---------------+|    (Kubectl)    |----------->| ( Master )  |<------+-----> |     Node 2    ||                 |            |             |       |       +---------------++-----------------+            |             |       |                               |             |       |       +---------------+                               |             |       +-----> |     Node 3    |                               |             |               +---------------+                               +-------------+</code></pre><p>其中 server 架构如下</p><h4 id="Master"><a href="#Master" class="headerlink" title="- Master"></a>- Master</h4><ul><li>ETCD: 存储集群所有需持久化的状态，并且提供 watch 的功能支持，可以快速的通知各组件的变更等操作</li><li>API Server: 接收外部的信号和请求，并将一些信息写入到 etcd 中。</li><li>Controller Manager: 在后台运行着许多不同的控制器进程，用来调节集群的状态。</li><li>Scheduler: Scheduler 是集群的调度器，它会持续的关注集群中未被调度的 Pod ，并根据各种条件，比如资源的可用性，节点的亲和性或者其他的一些限制条件，通过绑定的 API 将 Pod 调度/绑定到 Node 上。</li></ul><h4 id="Node"><a href="#Node" class="headerlink" title="- Node"></a>- Node</h4><p>Node 是 Kubernetes 集群架构中运行 Pod 的服务节点，用来承载被分配 Pod 的运行，是 Pod 运行的宿主机</p><ul><li>Kubelet: 负责管控容器，Kubelet 会从 Kubernetes API Server 接收 Pod 的创建请求，启动和停止容器，监控容器运行状态并汇报给 Kubernetes API Server。</li><li>Container Runtime: 容器运行时最主要的功能是下载镜像和运行容器，我们最常见的实现可能是 Docker , 目前还有其他的一些实现，比如 runc, Containered。<br>K8S 提供了一套通用的容器运行时接口 CRI (Container Runtime Interface), 凡是符合这套标准的容器运行时实现，均可在 K8S 上使用。</li><li>Kube Proxy<br>负责为 Pod 创建代理服务，KubeProxy 会从 API Server 获取所有的 Service 信息，并根据 Service 的信息创建代理服务，实现 Service 到 Pod 的请求路由和转发。</li></ul><h3 id="Kubernetes-核心概念"><a href="#Kubernetes-核心概念" class="headerlink" title="Kubernetes 核心概念"></a>Kubernetes 核心概念</h3><h4 id="Namespace"><a href="#Namespace" class="headerlink" title="- Namespace"></a>- Namespace</h4><p>Namespace 是对一组资源和对象的抽象集合，比如可以用来将系统内部的对象划分为不同的项目组或用户组。常见的 pods, services, replication controllers 和 deployments 等都是属于某一个 namespace 的（默认是 default），而 node, persistentVolumes 等则不属于任何 namespace。</p><p>Namespace 常用来隔离不同的用户，比如 Kubernetes 自带的服务一般运行在 kube-system namespace 中。</p><p>Namespace 定义实例:</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Namespace<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> demo</code></pre><blockquote><p>kubectl 可以通过–namespace 或者-n 选项指定 namespace。如果不指定，默认为 default。查看操作下,也可以通过设置–all-namespace=true 来查看所有 namespace 下的资源。</p></blockquote><h4 id="Pod"><a href="#Pod" class="headerlink" title="- Pod"></a>- Pod</h4><p>在 Kubernetes 中，最小的管理元素不是一个个独立的容器，而是 Pod,Pod 是最小的，管理，创建，计划的最小单元。一个 Pod 是一个容器环境下的“逻辑主机”，它可能包含一个或者多个紧密相连并且共享磁盘的容器。</p><p>Pod 定义文件示例:</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo  <span class="token key atrule">name</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo<span class="token punctuation">-</span>app  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> demo<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">#容器列表</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> sivdead/k8s<span class="token punctuation">-</span>demo<span class="token punctuation">:</span>0.0.8      <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> Always      <span class="token key atrule">name</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo      <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8081</span>      <span class="token key atrule">env</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> REDIS_HOST          <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"k8s-demo-redis"</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> REDIS_PORT          <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"6379"</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> REDIS_PASSWORD          <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"2JmUPwEf2W"</span></code></pre><h4 id="Label"><a href="#Label" class="headerlink" title="- Label"></a>- Label</h4><p>标签其实就一对 key/value ，被关联到资源上，比如 Pod,标签可以用来划分特定组的对象（比如，所有女的），标签可以在创建一个对象的时候直接给与，也可以在后期随时修改，每一个对象可以拥有多个标签，但是，key 值必须是唯一的。</p><h4 id="Label-Selector"><a href="#Label-Selector" class="headerlink" title="- Label Selector"></a>- Label Selector</h4><p>通过 Label Selector，客户端/用户能方便辨识出一组对象。Label Selector 是 kubernetes 中核心的组织原语。</p><p>API 目前支持两种选择器：基于相等的和基于集合的。一个 Label Selector 一可以由多个必须条件组成，由逗号分隔。在多个必须条件指定的情况下，所有的条件都必须满足，因而逗号起着 AND 逻辑运算符的作用。</p><h4 id="Replication-Controller"><a href="#Replication-Controller" class="headerlink" title="- Replication Controller"></a>- Replication Controller</h4><p>Replication Controller( 简称 RC )是 Kubernetes 系统中的核心概念之一,简单来说，它其实是定义了一个期望的场景,即声明某种 Pod 的副本数量在任意时刻都符合某个预期值,所以 RC 的定义包括如下几个部分:</p><ul><li>Pod 期待的副本数(replicas).</li><li>用于筛选目标 Pod 的 Label Selector.</li><li>当 Pod 的副本数量小于预期数量时,用于创建新 Pod 的 Pod 模板(template).</li></ul><p>ReplicaSet 是下一个版本的 RC,它和 RC 的唯一区别是: ReplicaSet 支持基于集合的 Label Selector,当前我们很少单独使用 ReplicaSet,它主要被 Deployment 这个更高层的资源对象所使用.</p><p>RC 定义文件示例:</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ReplicationController<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token comment" spellcheck="true">#标签选择器</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> sivdead/k8s<span class="token punctuation">-</span>demo<span class="token punctuation">:</span>0.0.8          <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> Always          <span class="token key atrule">name</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo          <span class="token key atrule">ports</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8081</span>          <span class="token key atrule">env</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> REDIS_HOST              <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"k8s-demo-redis"</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> REDIS_PORT              <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"6379"</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> REDIS_PASSWORD              <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"2JmUPwEf2W"</span></code></pre><h4 id="Deployment"><a href="#Deployment" class="headerlink" title="- Deployment"></a>- Deployment</h4><p>Deployment 为 Pod 和 ReplicaSet 提供了一个声明式定义(declarative)方法，用来替代以前的 ReplicationController 来方便的管理应用。典型的应用场景包括：</p><ul><li>定义 Deployment 来创建 Pod 和 ReplicaSet</li><li>滚动升级和回滚应用</li><li>扩容和缩容</li><li>暂停和继续 Deployment</li></ul><p>Deployment 定义文件示例:</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo  <span class="token key atrule">name</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo<span class="token punctuation">-</span>app  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> demo<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> sivdead/k8s<span class="token punctuation">-</span>demo<span class="token punctuation">:</span>0.0.8          <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> Always          <span class="token key atrule">name</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo          <span class="token key atrule">ports</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8081</span>          <span class="token key atrule">env</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> REDIS_HOST              <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"k8s-demo-redis"</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> REDIS_PORT              <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"6379"</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> REDIS_PASSWORD              <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"2JmUPwEf2W"</span></code></pre><h4 id="Horizontal-Pod-Autoscaling"><a href="#Horizontal-Pod-Autoscaling" class="headerlink" title="- Horizontal Pod Autoscaling"></a>- Horizontal Pod Autoscaling</h4><p>Horizontal Pod Autoscaling 可以根据 CPU 使用率或应用自定义 metrics 自动扩展 Pod 数量（支持 replication controller、deployment 和 replica set）。</p><ul><li>控制管理器每隔 30s（可以通过–horizontal-pod-autoscaler-sync-period 修改）查询 metrics 的资源使用情况</li><li>支持三种 metrics 类型<ul><li>预定义 metrics（比如 Pod 的 CPU）以利用率的方式计算</li><li>自定义的 Pod metrics，以原始值（raw value）的方式计算</li><li>自定义的 object metrics</li></ul></li><li>支持两种 metrics 查询方式：Heapster 和自定义的 REST API</li><li>支持多 metrics</li></ul><p>HPA 定义文件示例:</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> autoscaling/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> HorizontalPodAutoscaler<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> demo<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">maxReplicas</span><span class="token punctuation">:</span> <span class="token number">10</span>  <span class="token key atrule">minReplicas</span><span class="token punctuation">:</span> <span class="token number">1</span>  <span class="token comment" spellcheck="true">#自动扩容资源对象</span>  <span class="token key atrule">scaleTargetRef</span><span class="token punctuation">:</span>    <span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment    <span class="token key atrule">name</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo  <span class="token comment" spellcheck="true">#扩容的cpu使用率阀值</span>  <span class="token key atrule">targetCPUUtilizationPercentage</span><span class="token punctuation">:</span> <span class="token number">90</span></code></pre><h4 id="Service"><a href="#Service" class="headerlink" title="- Service"></a>- Service</h4><p>Kubernete Service 是一个定义了一组 Pod 的策略的抽象,Service 通过 Label Selector 来关联到一组 Pod,并将这些 Pod 的特定端口暴露出去,这种暴露可以是 ClusterIP 或 NodePort。</p><ul><li>NodePort: 使用这种方式暴露的 Service,可以直接使用 NodeIP:NodePort 来访问。</li><li>ClusterIP: ClusterIP 是一个虚拟的 ip 地址,只在集群内可以访问,这种一般是用负载均衡服务来作转发。</li></ul><p>Service 定义文件示例:</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo  <span class="token key atrule">name</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo<span class="token punctuation">-</span>app  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> demo<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo  <span class="token key atrule">ports</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8081</span>      <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP      <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">8081</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> ClusterIP</code></pre><h4 id="Secret"><a href="#Secret" class="headerlink" title="- Secret"></a>- Secret</h4><p>Secret 解决了密码、token、密钥等敏感数据的配置问题，而不需要把这些敏感数据暴露到镜像或者 Pod Spec 中。Secret 可以以 Volume 或者环境变量的方式使用。</p><p>Secret 有三种类型：</p><ul><li>Service Account：用来访问 Kubernetes API，由 Kubernetes 自动创建，并且会自动挂载到 Pod 的/run/secrets/kubernetes.io/serviceaccount 目录中；</li><li>Opaque：base64 编码格式的 Secret，用来存储密码、密钥等；</li><li>kubernetes.io/dockerconfigjson: 用来存储私有 docker registry 的认证信息。</li></ul><h4 id="Ingress"><a href="#Ingress" class="headerlink" title="- Ingress"></a>- Ingress</h4><p>Ingress 是一组允许外部请求进入集群的路由规则的集合。它可以给 Service 提供集群外部访问的 URL，负载均衡，SSL 终止等。</p><p>直白点说，Ingress 就类似起到了智能路由的角色，外部流量到达 Ingress ，再由它按已经制定好的规则分发到不同的后端服务中去。</p><p>Ingress 可以有多种控制器（实现）,目前由官方维护的有两个: 适用于 Google Cloud 的 <a href="https://github.com/kubernetes/ingress-gce" target="_blank" rel="noopener">GLBC</a>，当你使用 GKE 的时候，便会看到它；和 <a href="https://github.com/kubernetes/ingress-nginx" target="_blank" rel="noopener">NGINX Ingress Controller</a>，它是使用 ConfigMap 存储 Nginx 配置实现的。</p><p>Ingress 并不是 Kubernetes 自带的,需要自己手动安装。以下说明一下 NGINX Ingress Controller 的安装步骤:</p><blockquote><p>所有步骤皆为按配置文件创建资源,所以我只列了配置文件,安装时依次使用<code>kubectl apply -f filename</code>安装即可。<br>以下配置文件全部来自<a href="https://kubernetes.github.io/ingress-nginx/deploy/" target="_blank" rel="noopener">官方文档</a>,但是现在官方文档上改了,没有这个配置文件了,所以我把我保存的发出来.</p></blockquote><h4 id="1-创建-Namespace"><a href="#1-创建-Namespace" class="headerlink" title="1. 创建 Namespace"></a>1. 创建 Namespace</h4><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Namespace<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app.kubernetes.io/name</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx    <span class="token key atrule">app.kubernetes.io/part-of</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx</code></pre><h4 id="2-创建-configMap-nginx-配置文件"><a href="#2-创建-configMap-nginx-配置文件" class="headerlink" title="2. 创建 configMap(nginx 配置文件)"></a>2. 创建 configMap(nginx 配置文件)</h4><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>configuration  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app.kubernetes.io/name</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx    <span class="token key atrule">app.kubernetes.io/part-of</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx<span class="token punctuation">---</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> tcp<span class="token punctuation">-</span>services  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app.kubernetes.io/name</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx    <span class="token key atrule">app.kubernetes.io/part-of</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx<span class="token punctuation">---</span><span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> udp<span class="token punctuation">-</span>services  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app.kubernetes.io/name</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx    <span class="token key atrule">app.kubernetes.io/part-of</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx</code></pre><h4 id="3-创建帐号、角色及角色绑定"><a href="#3-创建帐号、角色及角色绑定" class="headerlink" title="3. 创建帐号、角色及角色绑定"></a>3. 创建帐号、角色及角色绑定</h4><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>serviceaccount  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app.kubernetes.io/name</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx    <span class="token key atrule">app.kubernetes.io/part-of</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>clusterrole  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app.kubernetes.io/name</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx    <span class="token key atrule">app.kubernetes.io/part-of</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx<span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">""</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> configmaps      <span class="token punctuation">-</span> endpoints      <span class="token punctuation">-</span> nodes      <span class="token punctuation">-</span> pods      <span class="token punctuation">-</span> secrets    <span class="token key atrule">verbs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> list      <span class="token punctuation">-</span> watch  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">""</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> nodes    <span class="token key atrule">verbs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> get  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">""</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> services    <span class="token key atrule">verbs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> get      <span class="token punctuation">-</span> list      <span class="token punctuation">-</span> watch  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"extensions"</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> ingresses    <span class="token key atrule">verbs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> get      <span class="token punctuation">-</span> list      <span class="token punctuation">-</span> watch  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">""</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> events    <span class="token key atrule">verbs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> create      <span class="token punctuation">-</span> patch  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"extensions"</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> ingresses/status    <span class="token key atrule">verbs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> update<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Role<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>role  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app.kubernetes.io/name</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx    <span class="token key atrule">app.kubernetes.io/part-of</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx<span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">""</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> configmaps      <span class="token punctuation">-</span> pods      <span class="token punctuation">-</span> secrets      <span class="token punctuation">-</span> namespaces    <span class="token key atrule">verbs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> get  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">""</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> configmaps    <span class="token key atrule">resourceNames</span><span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># Defaults to "&lt;election-id>-&lt;ingress-class>"</span>      <span class="token comment" spellcheck="true"># Here: "&lt;ingress-controller-leader>-&lt;nginx>"</span>      <span class="token comment" spellcheck="true"># This has to be adapted if you change either parameter</span>      <span class="token comment" spellcheck="true"># when launching the nginx-ingress-controller.</span>      <span class="token punctuation">-</span> <span class="token string">"ingress-controller-leader-nginx"</span>    <span class="token key atrule">verbs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> get      <span class="token punctuation">-</span> update  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">""</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> configmaps    <span class="token key atrule">verbs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> create  <span class="token punctuation">-</span> <span class="token key atrule">apiGroups</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">""</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> endpoints    <span class="token key atrule">verbs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> get<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> RoleBinding<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>role<span class="token punctuation">-</span>nisa<span class="token punctuation">-</span>binding  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app.kubernetes.io/name</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx    <span class="token key atrule">app.kubernetes.io/part-of</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io  <span class="token key atrule">kind</span><span class="token punctuation">:</span> Role  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>role<span class="token key atrule">subjects</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount    <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>serviceaccount    <span class="token key atrule">namespace</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRoleBinding<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>clusterrole<span class="token punctuation">-</span>nisa<span class="token punctuation">-</span>binding  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app.kubernetes.io/name</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx    <span class="token key atrule">app.kubernetes.io/part-of</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io  <span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>clusterrole<span class="token key atrule">subjects</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount    <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>serviceaccount    <span class="token key atrule">namespace</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx</code></pre><h4 id="4-创建-nginx-ingress-controller"><a href="#4-创建-nginx-ingress-controller" class="headerlink" title="4. 创建 nginx-ingress-controller"></a>4. 创建 nginx-ingress-controller</h4><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>controller  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app.kubernetes.io/name</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx    <span class="token key atrule">app.kubernetes.io/part-of</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app.kubernetes.io/name</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx      <span class="token key atrule">app.kubernetes.io/part-of</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app.kubernetes.io/name</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx        <span class="token key atrule">app.kubernetes.io/part-of</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx      <span class="token key atrule">annotations</span><span class="token punctuation">:</span>        <span class="token key atrule">prometheus.io/port</span><span class="token punctuation">:</span> <span class="token string">"10254"</span>        <span class="token key atrule">prometheus.io/scrape</span><span class="token punctuation">:</span> <span class="token string">"true"</span>    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">serviceAccountName</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>serviceaccount      <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>controller          <span class="token key atrule">image</span><span class="token punctuation">:</span> quay.io/kubernetes<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>controller/nginx<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>controller<span class="token punctuation">:</span>0.24.1          <span class="token key atrule">args</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> /nginx<span class="token punctuation">-</span>ingress<span class="token punctuation">-</span>controller            <span class="token punctuation">-</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>configmap=$(POD_NAMESPACE)/nginx<span class="token punctuation">-</span>configuration            <span class="token punctuation">-</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>tcp<span class="token punctuation">-</span>services<span class="token punctuation">-</span>configmap=$(POD_NAMESPACE)/tcp<span class="token punctuation">-</span>services            <span class="token punctuation">-</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>udp<span class="token punctuation">-</span>services<span class="token punctuation">-</span>configmap=$(POD_NAMESPACE)/udp<span class="token punctuation">-</span>services            <span class="token punctuation">-</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>publish<span class="token punctuation">-</span>service=$(POD_NAMESPACE)/ingress<span class="token punctuation">-</span>nginx            <span class="token punctuation">-</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>annotations<span class="token punctuation">-</span>prefix=nginx.ingress.kubernetes.io          <span class="token key atrule">securityContext</span><span class="token punctuation">:</span>            <span class="token key atrule">allowPrivilegeEscalation</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>            <span class="token key atrule">capabilities</span><span class="token punctuation">:</span>              <span class="token key atrule">drop</span><span class="token punctuation">:</span>                <span class="token punctuation">-</span> ALL              <span class="token key atrule">add</span><span class="token punctuation">:</span>                <span class="token punctuation">-</span> NET_BIND_SERVICE            <span class="token comment" spellcheck="true"># www-data -> 33</span>            <span class="token key atrule">runAsUser</span><span class="token punctuation">:</span> <span class="token number">33</span>          <span class="token key atrule">env</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> POD_NAME              <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>                <span class="token key atrule">fieldRef</span><span class="token punctuation">:</span>                  <span class="token key atrule">fieldPath</span><span class="token punctuation">:</span> metadata.name            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> POD_NAMESPACE              <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>                <span class="token key atrule">fieldRef</span><span class="token punctuation">:</span>                  <span class="token key atrule">fieldPath</span><span class="token punctuation">:</span> metadata.namespace          <span class="token key atrule">ports</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> http              <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> https              <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">443</span>          <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>            <span class="token key atrule">failureThreshold</span><span class="token punctuation">:</span> <span class="token number">3</span>            <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>              <span class="token key atrule">path</span><span class="token punctuation">:</span> /healthz              <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">10254</span>              <span class="token key atrule">scheme</span><span class="token punctuation">:</span> HTTP            <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">10</span>            <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">10</span>            <span class="token key atrule">successThreshold</span><span class="token punctuation">:</span> <span class="token number">1</span>            <span class="token key atrule">timeoutSeconds</span><span class="token punctuation">:</span> <span class="token number">10</span>          <span class="token key atrule">readinessProbe</span><span class="token punctuation">:</span>            <span class="token key atrule">failureThreshold</span><span class="token punctuation">:</span> <span class="token number">3</span>            <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>              <span class="token key atrule">path</span><span class="token punctuation">:</span> /healthz              <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">10254</span>              <span class="token key atrule">scheme</span><span class="token punctuation">:</span> HTTP            <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">10</span>            <span class="token key atrule">successThreshold</span><span class="token punctuation">:</span> <span class="token number">1</span>            <span class="token key atrule">timeoutSeconds</span><span class="token punctuation">:</span> <span class="token number">10</span></code></pre><h4 id="5-暴露-Ingress-Controller-服务"><a href="#5-暴露-Ingress-Controller-服务" class="headerlink" title="5. 暴露 Ingress Controller 服务"></a>5. 暴露 Ingress Controller 服务</h4><p>Ingress 的作用在于将集群外的请求流量转向集群内的服务，而默认情况下,集群外和集群内是不互通的，所以必须将 NGINX Ingress Controller 暴露至集群外，以便让其能接受来自集群外的请求,这里使用 NodePort 的方式暴露。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app.kubernetes.io/name</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx    <span class="token key atrule">app.kubernetes.io/part-of</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> NodePort  <span class="token key atrule">ports</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> http      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>      <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">80</span>      <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> https      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">443</span>      <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">443</span>      <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app.kubernetes.io/name</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx    <span class="token key atrule">app.kubernetes.io/part-of</span><span class="token punctuation">:</span> ingress<span class="token punctuation">-</span>nginx</code></pre><p>创建 service 之后,即可使用 NodeIp:NodePort,根据定义的路由规则访问其他服务。</p><p>Ingress 定义文件示例:</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 最新版的k8s使用的Ingress的apiVersion为networking.k8s.io/v1beta1</span><span class="token comment" spellcheck="true"># 这里用的是阿里云镜像服务可用的apiVersion</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo<span class="token punctuation">-</span>ingress  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> demo  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token key atrule">nginx.ingress.kubernetes.io/rewrite-target</span><span class="token punctuation">:</span> /$1<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">rules</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">http</span><span class="token punctuation">:</span>        <span class="token key atrule">paths</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">path</span><span class="token punctuation">:</span> /k8s<span class="token punctuation">-</span>demo/(.*)            <span class="token key atrule">backend</span><span class="token punctuation">:</span>              <span class="token comment" spellcheck="true"># 关联的Service名称</span>              <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> <span class="token string">"k8s-demo-app"</span>              <span class="token key atrule">servicePort</span><span class="token punctuation">:</span> <span class="token number">8081</span>      <span class="token comment" spellcheck="true"># 绑定的域名,创建后可以修改host文件来使用这个域名访问服务</span>      <span class="token key atrule">host</span><span class="token punctuation">:</span> sivded.com</code></pre><h3 id="Kubernetes-安装部署"><a href="#Kubernetes-安装部署" class="headerlink" title="Kubernetes 安装部署"></a>Kubernetes 安装部署</h3><h4 id="本地环境搭建"><a href="#本地环境搭建" class="headerlink" title="- 本地环境搭建"></a>- 本地环境搭建</h4><p>本地环境搭建简易可行的可选方式有两种:Kind 和 Minikube,这里推荐使用 Kind.</p><p>Kind 是 Kubernetes In Docker 的缩写，顾名思义是使用 Docker 容器作为 Node 并将 Kubernetes 部署至其中的一个工具。官方文档中也把 Kind 作为一种本地集群搭建的工具进行推荐。</p><h5 id="Kind-安装"><a href="#Kind-安装" class="headerlink" title="Kind 安装"></a>Kind 安装</h5><p>Kind 使用 Golang 进行开发，在仓库的 <a href="hhttps://github.com/kubernetes-sigs/kind/releases">Release</a> 页面，已经上传了构建好的二进制，支持多种操作系统，可直接按需下载进行使用。</p><p>示例:</p><pre class=" language-shell"><code class="language-shell"># 下载最新的 0.3.0 版本wget -O /usr/local/bin/kind https://github.com/kubernetes-sigs/kind/releases/download/0.2.0/kind-linux-amd64 && chmod +x /usr/local/bin/kind</code></pre><h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><ul><li>Kind 的主要功能目前需要有 Docker 环境的支持。</li><li>如果需要操作集群，则需要安装 kubectl 命令行。安装方法可参考<a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl" target="_blank" rel="noopener">官方文档</a>.</li></ul><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><pre class=" language-shell"><code class="language-shell"># --name指定cluster名称,如果不指定则为默认"kind"➜  ~ skind create cluster --name sivdeadCreating cluster "sivdead" ... ✓ Ensuring node image (kindest/node:v1.14.2) 🖼 ✓ Preparing nodes 📦 ✓ Creating kubeadm config 📜 ✓ Starting control-plane 🕹️Cluster creation complete. You can now use the cluster with:export KUBECONFIG="$(kind get kubeconfig-path --name="sivdead")"kubectl cluster-info</code></pre><p>命令中的输出让我们使用<code>export KUBECONFIG="$(kind get kubeconfig-path --name="sivdead")"</code>来配置 kubectl 环境变量,但这种方式只在当前窗口有效,实际可以修改<code>/etc/profile</code>来使配置永久生效.</p><pre class=" language-shell"><code class="language-shell">#kube configKUBECONFIG=`kind get kubeconfig-path --name='sivdead'`#添加KUBECONFIG环境变量export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL KUBECONFIG</code></pre><p>修改完成后 source 一下即可使用 kubectl 获取集群信息</p><pre class=" language-shell"><code class="language-shell">➜  ~ source /etc/profile➜  ~ kubectl cluster-infoKubernetes master is running at https://localhost:45560KubeDNS is running at https://localhost:45560/api/v1/namespaces/kube-system/services/kube-dns:dns/proxyTo further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.</code></pre><p>可以看到单节点的 Kubernetes 已经搭建成功.</p><p>这时候使用<code>docker ps</code>,也可以看到对应的 Node 容器正在运行.</p><pre class=" language-shell"><code class="language-shell">➜  ~ docker psCONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS              PORTS                                  NAMES1a69bb53e1b3        kindest/node:v1.14.2   "/usr/local/bin/entr…"   13 days ago         Up 13 days          45560/tcp, 127.0.0.1:45560->6443/tcp   kind-control-plane</code></pre><p>在 kind 拉取 Kubernetes 相关镜像时,可能会因为镜像源被墙导致拉取不到镜像报错.这时我们可以使用配置文件的方式来指定使用国内镜像.</p><p>首先删除刚才报错的镜像</p><pre class=" language-shell"><code class="language-shell">➜  ~ kind delete  cluster --name  sivdeadDeleting cluster "sivdead" ...$KUBECONFIG is still set to use /root/.kube/kind-config-sivdead even though that file has been deleted, remember to unset it</code></pre><p>然后创建<code>kind-config.yaml</code></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> Cluster<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> kind.sigs.k8s.io/v1alpha3<span class="token key atrule">kubeadmConfigPatches</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token punctuation">|</span><span class="token scalar string">    apiVersion: kubeadm.k8s.io/v1beta1    kind: ClusterConfiguration    metadata:      name: config    networking:      serviceSubnet: 10.0.0.0/16    imageRepository: registry.aliyuncs.com/google_containers    nodeRegistration:      kubeletExtraArgs:        pod-infra-container-image: registry.aliyuncs.com/google_containers/pause:3.1</span>  <span class="token punctuation">-</span> <span class="token punctuation">|</span><span class="token scalar string">    apiVersion: kubeadm.k8s.io/v1beta1    kind: InitConfiguration    metadata:      name: config    networking:      serviceSubnet: 10.0.0.0/16    imageRepository: registry.aliyuncs.com/google_containers</span><span class="token key atrule">nodes</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">role</span><span class="token punctuation">:</span> control<span class="token punctuation">-</span>plane</code></pre><p>使用该配置文件搭建集群:</p><pre class=" language-shell"><code class="language-shell">➜  ~  kind create cluster --name sivdead --config-kind.yamlCreating cluster "sivdead" ... ✓ Ensuring node image (kindest/node:v1.14.2) 🖼 ✓ Preparing nodes 📦 ✓ Creating kubeadm config 📜 ✓ Starting control-plane 🕹️Cluster creation complete. You can now use the cluster with:export KUBECONFIG="$(kind get kubeconfig-path --name="sivdead")"kubectl cluster-info</code></pre><h4 id="高可用集群搭建"><a href="#高可用集群搭建" class="headerlink" title="- 高可用集群搭建"></a>- 高可用集群搭建</h4><p>高可用集群可以使用 Kind 或者 Kubeadm 来搭建,具体可以参考:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/60464867?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=31223179116544" target="_blank" rel="noopener">使用 Kind 搭建你的本地 Kubernetes 集群</a></li><li><a href="https://www.kubernetes.org.cn/5273.html" target="_blank" rel="noopener">kubernetes v1.14.0 高可用 master 集群部署(使用 kubeadm)</a></li></ul><h3 id="kubectl-常用命令"><a href="#kubectl-常用命令" class="headerlink" title="kubectl 常用命令"></a>kubectl 常用命令</h3><p>kubectl 命令行的语法如下:</p><pre class=" language-shell"><code class="language-shell">kubectl [command] [TYPE] [NAME] [flags]</code></pre><ul><li><p>command: 子命令,用于操作集群资源对象的命令,常用命令:</p><ul><li><p>create: 创建资源对象</p></li><li><p>apply: 从配置文件或 stdin 中对资源对象进行配置更新,也可以用于创建资源对象</p></li><li><p>scale: 扩容/缩容一个 Deployment、ReplicaSet、RC 或 Job 中 Pod 的数量,可以将 Pod 数量设置为 0 来达到暂时停止应用的目的.</p></li><li><p>delete: 删除资源对象,可通过-f=filename 以配置文件格式指定删除的内容</p></li><li><p>describe: 描述资源对象,describe 在排查错误时非常有用</p></li><li><p>get: 查看资源对象,可以使用<code>--watch</code>来动态查看资源对象列表</p></li><li><p>exec: 执行容器的命令,通常可以使用下列命令来进入到某个 pod 容器的 bash 命令行.</p><pre class=" language-shell"><code class="language-shell"># -c 指定容器名称,如果不指定,则默认使用pod中的第一个容器kubectl exec -it podName -c containerName /bin/bash</code></pre></li><li><p>logs: 查看容器的日志,参数<code>-f</code>可以达到类似<code>tailf</code>的效果</p></li><li><p>cp: 从容器中复制文件,要求容器中可以使用<code>tar</code>命令,用法:</p><pre class=" language-shell"><code class="language-shell">kubectl cp <namespace>/<pod>:<src-filepath> <namespace>/<pod>:<dest-filepath> [options]</code></pre></li></ul></li><li><p>TYPE: 资源对象的类型,区分大小写,能以单数形式、复数形式、简写形式表示.例如下列 3 种 TYPE 是等价的.</p></li></ul><pre class=" language-shell"><code class="language-shell">kubectl get podkubectl get podskubectl get po</code></pre><p> 常用资源对象及其简写如下:</p><table><thead><tr><th>资源对象名称</th><th>简写</th></tr></thead><tbody><tr><td>configmap</td><td>cm</td></tr><tr><td>deployment</td><td>deploy</td></tr><tr><td>ingress</td><td>ing</td></tr><tr><td>node</td><td>no</td></tr><tr><td>namespace</td><td>ns</td></tr><tr><td>pod</td><td>po</td></tr><tr><td>replicationcontroller</td><td>rc</td></tr><tr><td>replicaset</td><td>rs</td></tr><tr><td>service</td><td>svc</td></tr></tbody></table><ul><li>NAME: 资源对象的名称,区分大小写.如果不指定名称,则系统将返回属于 TYPE 的全部对象的列表,例如<code>kubectl get pod</code>将返回所有 pod 的列表</li><li>flags: kubectl 子命令的可选参数,例如使用<code>-n</code>指定 Namespace.常用参数:<ul><li><code>-n</code>: 指定 Namespace,如果不指定则使用 default</li><li><code>-o</code>: 指定输出格式,可以将输出格式修改为 yaml 或者 json 等格式,也可以指定返回的字段。</li></ul></li></ul><h3 id="Quick-Start-使用-Kubernetes-发布应用"><a href="#Quick-Start-使用-Kubernetes-发布应用" class="headerlink" title="Quick Start: 使用 Kubernetes 发布应用"></a>Quick Start: 使用 Kubernetes 发布应用</h3><p>我们使用之前编写的简单计数应用镜像。</p><p>首先,编写配置文件:</p><ul><li>Namespace:</li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Namespace<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> demo</code></pre><ul><li>Deployment:</li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo  <span class="token key atrule">name</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo<span class="token punctuation">-</span>app  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> demo<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> sivdead/k8s<span class="token punctuation">-</span>demo<span class="token punctuation">:</span>0.0.1          <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> Always          <span class="token key atrule">name</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo          <span class="token key atrule">ports</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8081</span>          <span class="token key atrule">env</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> REDIS_HOST              <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"k8s-demo-redis"</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> REDIS_PORT              <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"6379"</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> REDIS_PASSWORD              <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"123456"</span></code></pre><ul><li>Service:</li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo  <span class="token key atrule">name</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo<span class="token punctuation">-</span>app  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> demo<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo  <span class="token key atrule">ports</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8081</span>      <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP      <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">8081</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> ClusterIP</code></pre><ul><li>Ingress</li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo<span class="token punctuation">-</span>ingress  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> demo  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token key atrule">nginx.ingress.kubernetes.io/rewrite-target</span><span class="token punctuation">:</span> /$1<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">rules</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">http</span><span class="token punctuation">:</span>        <span class="token key atrule">paths</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">path</span><span class="token punctuation">:</span> /k8s<span class="token punctuation">-</span>demo/(.*)            <span class="token key atrule">backend</span><span class="token punctuation">:</span>              <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> <span class="token string">"k8s-demo-app"</span>              <span class="token key atrule">servicePort</span><span class="token punctuation">:</span> <span class="token number">8081</span>      <span class="token key atrule">host</span><span class="token punctuation">:</span> sivdead.com</code></pre><ul><li>Redis Deployment</li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> redis  <span class="token key atrule">name</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo<span class="token punctuation">-</span>redis  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> demo<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> redis  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> redis    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> redis<span class="token punctuation">:</span><span class="token number">4.0</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> redis          <span class="token key atrule">ports</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">6379</span>          <span class="token key atrule">args</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token string">'--requirepass 123456'</span></code></pre><ul><li>Redis Service</li></ul><p>因为 redis 不需要被集群外部使用,所以使用 ClusterIP 即可</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> redis  <span class="token key atrule">name</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>demo<span class="token punctuation">-</span>redis  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> demo<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>      <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP      <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">6379</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> redis  <span class="token key atrule">type</span><span class="token punctuation">:</span> ClusterIP</code></pre><p>使用<code>kubectl apply -f</code>轮流创建资源后,修改<code>/etc/hosts</code>文件,增加<code>sivdead.com</code>对应<code>NGINX Ingress Controller</code>的<code>NodeIP:NodePort</code></p><pre class=" language-shell"><code class="language-shell">➜  ~ kubectl -n ingress-nginx get svcNAME            TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)                      AGEingress-nginx   NodePort   10.105.250.114   <none>        80:31895/TCP,443:31693/TCP   2d13h➜  ~ kubectl describe node kind-control-planeName:               kind-control-plane# 忽略...Addresses:  InternalIP:  172.17.0.2  Hostname:    kind-control-plane# 忽略...➜  ~ cat >>/etc/hosts<<EOFheredoc> 172.17.0.2   sivdead.comheredoc> EOF</code></pre><p>查看 demo Namespace 各资源的状态</p><pre class=" language-shell"><code class="language-shell">➜  ~ kubectl -n demo get allNAME                                  READY   STATUS    RESTARTS   AGEpod/k8s-demo-app-696b78444b-vn2kj     1/1     Running   3          2d22hpod/k8s-demo-redis-7cf684b8ff-grlx6   1/1     Running   1          2d22hNAME                     TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGEservice/k8s-demo-app     ClusterIP   10.107.18.40    <none>        8081/TCP         2d13hservice/k8s-demo-redis   NodePort    10.104.21.255   <none>        6379:32201/TCP   2d22hNAME                             READY   UP-TO-DATE   AVAILABLE   AGEdeployment.apps/k8s-demo-app     1/1     1            1           2d22hdeployment.apps/k8s-demo-redis   1/1     1            1           2d22hNAME                                        DESIRED   CURRENT   READY   AGEreplicaset.apps/k8s-demo-app-696b78444b     1         1         1       2d22hreplicaset.apps/k8s-demo-app-854b97479d     0         0         0       2d22hreplicaset.apps/k8s-demo-redis-7cf684b8ff   1         1         1       2d22h</code></pre><p>如果所有资源都在正常运行,使用 curl 测试接口:</p><pre class=" language-shell"><code class="language-shell">➜  ~ curl sivdead.com:31895/k8s-demo/scorescore is: 10#</code></pre><p>说明应用已经部署成功。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote><ul><li>掘金小册<a href="https://juejin.im/book/5b9b2dc86fb9a05d0f16c8ac" target="_blank" rel="noopener">《Kubernetes 从上手到实践-张晋涛》</a></li><li>电子工业出版社《Kubernetes 权威指南》</li></ul></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 容器化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> k8s </tag>
            
            <tag> 容器化 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
